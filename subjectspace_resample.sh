#!/usr/bin/env bash

# ARG_HELP([Resampling from common space to subject space for modelbuild.sh from optimized_antsMultivariateTemplateConstruction])
# ARG_OPTIONAL_SINGLE([output-dir],[],[Output directory for modelbuild],[output])
# ARG_OPTIONAL_BOOLEAN([float],[],[Use float instead of double for calculations (reduce memory requirements, reduce precision)],[])
# ARG_OPTIONAL_SINGLE([type],[],[Resampled input type, define interpolation type],[label])
# ARG_TYPE_GROUP_SET([typegroup],[TYPE],[type],[label,quantitative,image])
# ARG_OPTIONAL_SINGLE([resample-input-space],[],[Initial space of the input to be resampled (unbiased, final-target, or secondlevel for twolevel wrapper)],[unbiased])
# ARG_TYPE_GROUP_SET([spacegroup],[SPACE],[resample-input-space],[unbiased,final-target,secondlevel])
# ARG_OPTIONAL_SINGLE([walltime],[],[Walltime for resampling],[00:15:00])
# ARG_OPTIONAL_BOOLEAN([block],[],[For qbatch SGE, PBS and SLURM, blocks execution until jobs are finished.],[])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Debug mode, print all commands to stdout],[])
# ARG_OPTIONAL_BOOLEAN([dry-run],[],[Dry run, don't run any commands, implies debug],[])
# ARG_OPTIONAL_SINGLE([jobname-prefix],[],[Prefix to add to front of job names, used by twolevel wrapper],[])
# ARG_OPTIONAL_SINGLE([resample-input],[],[File to be resampled into subject space],[])
# ARG_OPTIONAL_SINGLE([append-transforms],[],[Transform files which align modelbuild inputs to target-space, will be applied at the end of the transform chain, append with :1 to indicate applying the inverse],[])
# ARG_OPTIONAL_SINGLE([prepend-transforms],[],[Comma separated list of transforms to add to the transform stack, used by twolevel wrapper],[])
# ARG_OPTIONAL_SINGLE([target-space],[],[Target space for each subject, structured the same as the input to modelbuild.sh. inputs is used if not specified.],[])
# ARG_POSITIONAL_SINGLE([inputs],[Input text files, one line per input, same as those provided to modelbuild.sh],[])

# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

# validators

typegroup()
{
	local _allowed=("label" "quantitative" "image") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'label', 'quantitative' and 'image'" 4
}


spacegroup()
{
	local _allowed=("unbiased" "final-target" "secondlevel") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'unbiased', 'final-target' and 'secondlevel'" 4
}


begins_with_short_option()
{
  local first_option all_short_options='h'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output_dir="output"
_arg_float="off"
_arg_type="label"
_arg_resample_input_space="unbiased"
_arg_walltime="00:15:00"
_arg_block="off"
_arg_debug="off"
_arg_dry_run="off"
_arg_jobname_prefix=
_arg_resample_input=
_arg_append_transforms=
_arg_prepend_transforms=
_arg_target_space=


print_help()
{
  printf '%s\n' "Resampling from common space to subject space for modelbuild.sh from optimized_antsMultivariateTemplateConstruction"
  printf 'Usage: %s [-h|--help] [--output-dir <arg>] [--(no-)float] [--type <TYPE>] [--resample-input-space <SPACE>] [--walltime <arg>] [--(no-)block] [--(no-)debug] [--(no-)dry-run] [--jobname-prefix <arg>] [--resample-input <arg>] [--append-transforms <arg>] [--prepend-transforms <arg>] [--target-space <arg>] <inputs>\n' "$0"
  printf '\t%s\n' "<inputs>: Input text files, one line per input, same as those provided to modelbuild.sh"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "--output-dir: Output directory for modelbuild (default: 'output')"
  printf '\t%s\n' "--float, --no-float: Use float instead of double for calculations (reduce memory requirements, reduce precision) (off by default)"
  printf '\t%s\n' "--type: Resampled input type, define interpolation type. Can be one of: 'label', 'quantitative' and 'image' (default: 'label')"
  printf '\t%s\n' "--resample-input-space: Initial space of the input to be resampled (unbiased, final-target, or secondlevel for twolevel wrapper). Can be one of: 'unbiased', 'final-target' and 'secondlevel' (default: 'unbiased')"
  printf '\t%s\n' "--walltime: Walltime for resampling (default: '00:15:00')"
  printf '\t%s\n' "--block, --no-block: For qbatch SGE, PBS and SLURM, blocks execution until jobs are finished. (off by default)"
  printf '\t%s\n' "--debug, --no-debug: Debug mode, print all commands to stdout (off by default)"
  printf '\t%s\n' "--dry-run, --no-dry-run: Dry run, don't run any commands, implies debug (off by default)"
  printf '\t%s\n' "--jobname-prefix: Prefix to add to front of job names, used by twolevel wrapper (no default)"
  printf '\t%s\n' "--resample-input: File to be resampled into subject space (no default)"
  printf '\t%s\n' "--append-transforms: Transform files which align modelbuild inputs to target-space, will be applied at the end of the transform chain, append with :1 to indicate applying the inverse (no default)"
  printf '\t%s\n' "--prepend-transforms: Comma separated list of transforms to add to the transform stack, used by twolevel wrapper (no default)"
  printf '\t%s\n' "--target-space: Target space for each subject, structured the same as the input to modelbuild.sh. inputs is used if not specified. (no default)"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      --output-dir)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_output_dir="$2"
        shift
        ;;
      --output-dir=*)
        _arg_output_dir="${_key##--output-dir=}"
        ;;
      --no-float|--float)
        _arg_float="on"
        test "${1:0:5}" = "--no-" && _arg_float="off"
        ;;
      --type)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_type="$(typegroup "$2" "type")" || exit 1
        shift
        ;;
      --type=*)
        _arg_type="$(typegroup "${_key##--type=}" "type")" || exit 1
        ;;
      --resample-input-space)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_resample_input_space="$(spacegroup "$2" "resample-input-space")" || exit 1
        shift
        ;;
      --resample-input-space=*)
        _arg_resample_input_space="$(spacegroup "${_key##--resample-input-space=}" "resample-input-space")" || exit 1
        ;;
      --walltime)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_walltime="$2"
        shift
        ;;
      --walltime=*)
        _arg_walltime="${_key##--walltime=}"
        ;;
      --no-block|--block)
        _arg_block="on"
        test "${1:0:5}" = "--no-" && _arg_block="off"
        ;;
      --no-debug|--debug)
        _arg_debug="on"
        test "${1:0:5}" = "--no-" && _arg_debug="off"
        ;;
      --no-dry-run|--dry-run)
        _arg_dry_run="on"
        test "${1:0:5}" = "--no-" && _arg_dry_run="off"
        ;;
      --jobname-prefix)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_jobname_prefix="$2"
        shift
        ;;
      --jobname-prefix=*)
        _arg_jobname_prefix="${_key##--jobname-prefix=}"
        ;;
      --resample-input)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_resample_input="$2"
        shift
        ;;
      --resample-input=*)
        _arg_resample_input="${_key##--resample-input=}"
        ;;
      --append-transforms)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_append_transforms="$2"
        shift
        ;;
      --append-transforms=*)
        _arg_append_transforms="${_key##--append-transforms=}"
        ;;
      --prepend-transforms)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_prepend_transforms="$2"
        shift
        ;;
      --prepend-transforms=*)
        _arg_prepend_transforms="${_key##--prepend-transforms=}"
        ;;
      --target-space)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_target_space="$2"
        shift
        ;;
      --target-space=*)
        _arg_target_space="${_key##--target-space=}"
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'inputs'"
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_inputs "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
# Validation of values



### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
set -uo pipefail
set -eE -o functrace

# Load up helper scripts and define helper variables
# shellcheck source=helpers.sh
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/helpers.sh"

# Set magic variables for current file, directory, os, etc.
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"

if [[ ${_arg_debug} == "off" ]]; then
  unset _arg_debug
fi

# Prefight check for required programs
preflight_check

# Setup a directory which contains all commands run
# for this invocation
mkdir -p ${_arg_output_dir}/jobs/${__datetime}
export QBATCH_SCRIPT_FOLDER="${_arg_output_dir}/qbatch/${__datetime}"

# Store the full command line for each run
echo ${__invocation} >${_arg_output_dir}/jobs/${__datetime}/invocation

info "Checking input files"

# Set target space to modelbuild indputs if empty
if [ -z "$_arg_target_space" ]; then
  _arg_target_space=${_arg_inputs}
fi

# Load input file into array
if [[ ! -s ${_arg_inputs[0]} ]]; then
  failure "Input file ${_arg_inputs[0]} is non-existent or zero size"
else
  mapfile -t _arg_inputs <${_arg_inputs[0]}
fi

# Load target space into array
if [[ ! -s ${_arg_target_space[0]} ]]; then
  failure "Input file ${_arg_target_space[0]} is non-existent or zero size"
else
  mapfile -t _arg_target_space <${_arg_target_space[0]}
fi

# Check if resample-input exists
if [[ ! -s ${_arg_resample_input} ]]; then
  failure "Input file ${_arg_resample_input} is non-existent or zero size"
fi

# Enable float mode for ants commands
if [[ ${_arg_float} == "on" ]]; then
  _arg_float="--float"
else
  _arg_float=""
fi

# Enable block for qbatch job submission
if [[ ${_arg_block} == "on" ]]; then
  _arg_block="--block"
else
  _arg_block=""
fi

if [[ ! -s ${_arg_output_dir}/final/average/template_sharpen_shapeupdate.nii.gz ]]; then
  failure "Modelbuild is not complete, ${_arg_output_dir}/final/average/template_sharpen_shapeupdate.nii.gz is zero size or does not exist"
fi

if [[ ${_arg_type} == "quantitative" ]]; then
  interpolation="--interpolation Linear"
elif [[ ${_arg_type} == "image" ]]; then
  interpolation="--interpolation BSpline[5]"
elif [[ ${_arg_type} == "label" ]]; then
  interpolation="--interpolation GenericLabel"
fi

# Find transform files from resample-inputs to commonspace
if [[ ${_arg_resample_input_space} == "final-target" ]]; then
  inversewarp_to_final_target=${_arg_output_dir}/final-target/to_target_1InverseWarp.nii.gz
  if [[ -s ${inversewarp_to_final_target} ]]; then
    final_target_transforms="-t [${_arg_output_dir}/final-target/to_target_0GenericAffine.mat,1] -t ${inversewarp_to_final_target} "
  else
    fatal "Final target transform ${inversewarp_to_final_target} not found"
  fi
  output_folder_prefix="subject"
elif [[ ${_arg_resample_input_space} == "unbiased" ]]; then
  final_target_transforms=""
  output_folder_prefix="subject"
elif [[ ${_arg_resample_input_space} == "secondlevel" ]]; then
  final_target_transforms=${_arg_prepend_transforms}
  output_folder_prefix="session"
fi

i=0
resample_input_basename=$(basename ${_arg_resample_input} | extension_strip)
for file in "${_arg_inputs[@]}"; do
  # Establish output name
  file_basename=$(basename ${_arg_target_space[i]} | extension_strip)
  real_outputdir=${_arg_output_dir}/subjectspace-resample/${output_folder_prefix}_$((i + 1))/
  mkdir -p ${real_outputdir}
  ants_output=${real_outputdir}/${resample_input_basename}_to_${file_basename}.nii.gz
  if [[ ! -s ${ants_output} ]]; then
    if [[ -n ${_arg_append_transforms[i]:-} ]]; then
      if [[ "${_arg_append_transforms[i]}" == *:1 ]]; then
        transform_resample_input_to_input="-t [ ${_arg_append_transforms[i]%:1},1 ]"
      else
        transform_resample_input_to_input="-t ${_arg_append_transforms[i]}"
      fi
    else
      transform_resample_input_to_input=""
    fi
    echo antsApplyTransforms -d 3 --verbose ${_arg_float} \
                             -i ${_arg_resample_input} \
                             ${interpolation} \
                             -r ${_arg_target_space[i]} \
                             ${transform_resample_input_to_input} \
                             -t [${_arg_output_dir}/final/transforms/$(basename ${file} | extension_strip)_0GenericAffine.mat,1] \
                             -t ${_arg_output_dir}/final/transforms/$(basename ${file} | extension_strip)_1InverseWarp.nii.gz \
                             ${final_target_transforms} \
                             -o ${ants_output}
  fi
  ((++i))
done > ${_arg_output_dir}/jobs/${__datetime}/subjectspace_resampled

debug "$(cat ${_arg_output_dir}/jobs/${__datetime}/subjectspace_resampled)"
if [[ ${_arg_dry_run} == "off" ]]; then
  qbatch ${_arg_block} --logdir ${_arg_output_dir}/logs/${__datetime} \
    --walltime ${_arg_walltime} \
    -N ${_arg_jobname_prefix}subjectspace_resampled_${__datetime} \
    ${_arg_output_dir}/jobs/${__datetime}/subjectspace_resampled
fi

# ] <-- needed because of Argbash
