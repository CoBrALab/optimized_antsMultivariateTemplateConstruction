#!/bin/bash
#
# ARG_OPTIONAL_SINGLE([suffix],[],[BIDS file suffix to construct inputs with],[T1w])
# ARG_OPTIONAL_SINGLE([derivatives],[],[Derivatives sub-path to use (for preprocessed data)],[NA])

# ARG_OPTIONAL_REPEATED([column-filter],[],[Use to filter other BIDS entity types])

# ARG_OPTIONAL_SINGLE([masks],[],[Generate brain masks file],[])

# ARG_POSITIONAL_SINGLE([input_bids],[Path to BIDS dataset top-level directory],[])
# ARG_POSITIONAL_SINGLE([output],[CSV filename to save],[])
# ARG_HELP([Helper script to parse a BIDS-formatted dataset and generate an input.csv for modelbuild.sh])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

begins_with_short_option() {
  local first_option all_short_options='h'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_suffix="T1w"
_arg_derivatives="NA"
_arg_column_filter=()
_arg_masks=

print_help() {
  printf '%s\n' "Helper script to parse a BIDS-formatted dataset and generate an input.csv for modelbuild.sh"
  printf 'Usage: %s [--suffix <arg>] [--derivatives <arg>] [--column-filter <arg>] [--masks <arg>] [-h|--help] <input_bids> <output>\n' "$0"
  printf '\t%s\n' "<input_bids>: Path to BIDS dataset top-level directory"
  printf '\t%s\n' "<output>: CSV filename to save"
  printf '\t%s\n' "--suffix: BIDS file suffix to construct inputs with (default: 'T1w')"
  printf '\t%s\n' "--derivatives: Derivatives sub-path to use (for preprocessed data) (default: 'NA')"
  printf '\t%s\n' "--column-filter: Use to filter other BIDS entity types (empty by default)"
  printf '\t%s\n' "--masks: Generate brain masks file (no default)"
  printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
  _positionals_count=0
  local _key
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    --suffix)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_suffix="$2"
      shift
      ;;
    --suffix=*)
      _arg_suffix="${_key##--suffix=}"
      ;;
    --derivatives)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_derivatives="$2"
      shift
      ;;
    --derivatives=*)
      _arg_derivatives="${_key##--derivatives=}"
      ;;
    --column-filter)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_column_filter+=("$2")
      shift
      ;;
    --column-filter=*)
      _arg_column_filter+=("${_key##--column-filter=}")
      ;;
    --masks)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_masks="$2"
      shift
      ;;
    --masks=*)
      _arg_masks="${_key##--masks=}"
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    *)
      _last_positional="$1"
      _positionals+=("$_last_positional")
      _positionals_count=$((_positionals_count + 1))
      ;;
    esac
    shift
  done
}

handle_passed_args_count() {
  local _required_args_string="'input_bids' and 'output'"
  test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
  local _positional_name _shift_for=$1
  _positional_names="_arg_input_bids _arg_output "

  shift "$_shift_for"
  for _positional_name in ${_positional_names}; do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

set -uo pipefail
set -eE -o functrace

# Load up helper scripts and define helper variables
# shellcheck source=helpers.sh
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/helpers.sh"
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/libBIDS.sh/libBIDS.sh"

# Set magic variables for current file, directory, os, etc.
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"

bids_table=$(libBIDSsh_parse_bids_to_csv "${_arg_input_bids}")

# Prefix filters with the proper option
_column_filter_args=()
for filter in "${_arg_column_filter[@]}"; do
  _column_filter_args+=("-r" "$filter")
done

filtered_image_table=$(libBIDSsh_csv_filter "${bids_table}" \
  -r "suffix:${_arg_suffix}" \
  -r "extension:(nii|nii.gz)" \
  -r "derivatives:${_arg_derivatives}" \
  "${_column_filter_args[@]}")

declare -A row
while libBIDSsh_csv_iterator "$filtered_image_table" row "subject" "session"; do
  printf "%s\n" "${row[path]}"
done >"${_arg_output}"

if [[ -n "${_arg_masks}" ]]; then
  filtered_mask_table=$(libBIDSsh_csv_filter "${bids_table}" \
    -r "suffix:mask" \
    -r "extension:(nii|nii.gz)" \
    -r "derivatives:${_arg_derivatives}" \
    "${_column_filter_args[@]}")
  declare -A row
  while libBIDS_csv_iterator "$filtered_mask_table" row "subject" "session"; do
    printf "%s\n" "${row[path]}"
  done >"${_arg_masks}"
fi

# ] <-- needed because of Argbash
